**DESIGN.md**

 - provides the high-level design goals of your project
	 - My overall goal for this project was to make a highly modular, easily maintainable, navigable, and extensible game using the model-view-controller (MVC) design pattern. 
	 - I wanted to approach the design of the game in a very organized and methodical fashion, beginning with a careful design of the class heirarchy before writing any code. I wanted to make sure that started the project by implementing the most basic and foundational features first (such as displaying objects on the screen, moving objects on the screen, adding physics to the object movement, adding collision detection, and then piecing everything together).  I strived to make each commit meaningful, but small. Every time I pushed to gitlab, I wanted to ensure that I was pushing a working version of my code.  
	 - My goals for a highly modular design and small commit messages went hand in hand.  Dividing up the work of my game into small, logical units, I could add small new features, make sure they work, and then move on to the next one.  This ensured that I always had a clear idea of what feature to add next.
	 - Much of the design of my game focused on easily being able to stitch individual pieces together.  By dividing up my game into individual scenes with a common transportation mechanism between them, I made the game easily customizable, such that adding new levels or changing movement mechanics is straightforward.
 - explains, in detail, how to add new features to your project
	 - Suppose I wanted to add a new level to my game, in which characters experienced a different level of gravity.  
		 - Adding a new level is fairly straightforward.  I would begin by first creating a new class in the Scene directory which extends GameScene in order to get all basic properties of GameScene, and to be identified with the GameScene objects.  This class would be constructed based on the dimensions specified by the constructor. New objects in the scene would be arranged simply by setting the x and y coordinates relative to the input scene dimensions.  
		 - In order to reach that new scene, I would have to create a path to it in my game.  The way things are currently implemented, the paths are doubly linked lists, and as such, I am only capable of creating a linear game path.  However, I could easily change this.  Instead of having a single tunnel to the next scene, I could maintain a list of outbound tunnels, each of which map to (potentially) a different game scene. The destination of that outward-bound tunnel points back to some other tunnel.  One could design the destination tunnel to have a source scene to be the most recently visited scene, or it could be implemented more simply by specifying it's destination on construction. Once all of the levels have been linked properly and there is a valid path, a new level has been created.
		 - One part of my design is problematic, however.  My code has been written under the assumption that the only level with physics disabled is the DoorExplorationScene (the scene with all of the Taylors).  However, we note that "disabling physics" really just means setting gravity = 0.  Thus, the special cases I made for moving the character could be greatly simplified by:
			 - 1: Making the gravity a property of the scene itself, instead of implicitly doing so by checking instanceof DoorExplorationScene
			 - 2: If the Gravity of the scene is 0, then characters can move left, right, up, and down, as if you're overlooking them instead of looking at them from the side.
		 - If  I made gravity a property of the scene upon construction, then defining new level of gravity in the new scene would be trivial. My current design goes part of the way towards this objective... In updateJumpingTrajectory, an input argument is the gravity of the scene.  Simply changing gravity from being set at the GameController level to the Scene level would make a world of a difference.
	 - Suppose I wanted to add a new character to my game.
		 - Doing so would be fairly straightward.  I would first create a new class which extends Character, define a createNewCharacter method, and define a moveCharacter method.  Then, I would construct this character in my GameController, and add a call to this character's moveCharacter method in the GameController's moveCharacters method. If this character needed to interact with the main character, I could notify the main character of this character's existence by adding some reference to the character in the main character controller's fields. That main character could then decide how to interact with the new character, and these reponses would be called by the game controller upon some signal of interaction.
 - justifies major design choices, including trade-offs (i.e., pros and cons), made in your project
	 - One major design decision in my project revolved around the question of how to manage character / environment interactions in a managable and maintainable way.  
		 - In order to accomplish this, I strove to organize my controller code into logical units.  Since the main components of the game are characters and scenes, I chose to make the logical split into character controllers and a scene controller.  To ensure my code was easy to navigate and maintain, I decided to make the character controllers and scene controllers not know about each other directly. Instead, I created a GameController class, which manages the interactions between the characters and the scene. The only objects which the character controller knows about are those which the game controller decides to pass to the CharacterController from the SceneController.  This made adding new characters to the game quite easy, and made managing the construction and destruction of the scene easy from the perspective of the game.
		 - One issue that arose as my game gained more and more features, however, was that the GameController, which mediates all the game interactions, became increasingly heavyweight.  One good example of this is the method handleSceneTransition in my code.  As more and more GameScenes are added, the if tree becomes larger and larger here. This seems to suggest that polymorphism is not being adequately exploited.  Perhaps, if the scene itself defined which song it played, and what kind of elements (gold, enemies, ect.) are to exist in the scene, the if statements could be removed completely in favor of a polymorphic method.
		 - For all of the faults in this class, however, many of the methods remained quite clean and simple. One good example is the step method.  While heavily involving helper methods, the step method itself is very readable. Since it is one of the most important methods in GameController, I strove to keep it simple and understandable so new features were easier to add to it.
	 - Another big design decision came about in designing the views class heirarchy.
		 - In order to keep the views as modular as possible, I began by defining a view element for each object that would appear in the scene.  Using superclasses ViewElement and SceneElement.java, I was able to capture a lot of shared code together.  Separating these objects into such small groups became particularly useful when defining objects and tunnels.  Using Java's reflection, I was able to easily create logic for when a character finds an obstacle and when a character finds a tunnel obstacle.  This greatly aided in simplifying my code logic.
		 - However, going through many of my subclasses, many seem somewhat unneeded.  For example, there is no functional difference between a Wall and Grass in terms of the code; they essentially only differ by the picture they use. Perhaps I went a bit to the extreme with creating subclasses.  However, these subclasses had the advantage of making scene construction more readable than if the classes were more general purpose.
	 - Another decision I contemplated for a while was how to best organize constants that needed to be accessed by many different classes.
		 - For example, I wanted a centralized location to store the names of all of my songs and images.  The cleanest way I could come up with to organize these strings was in a public final class with public static final String fields. This had the perk of giving me easy access to exactly the string I wanted to reference, no matter where in the code I was.  
		 - However, this decision has drawbacks.  Most notably, when writing a method that is supposed to take a song or image name as an input argument, under my current design, there is no clean way to enforce the inputs to be a finite set of options.  What I wished I could have done is made a enum where all of the values are strings, and where the values are easily accessible.  Though I spent some time searching the web for a solution along these lines, I never found something clean enough to lure me away from my initial design.  I am sure there is a better way than what I did, I just am not quite sure what that way is.
 - states any assumptions or decisions made to simplify or resolve ambiguities in the project's functionality
	 -  One simplifying assumption I made was to separate the Character class from the Obstacle class.  It perhaps would have been nice to have, when my character jumps on an enemy, for him to treat that enemy like an obstacle.  However, since the having characters interact with enemies the same way they interact obstacles did not always seem natural, I decided to keep them separate.
	 - Another simplifying assumption I made when designing scene transitions was that the scene path graph is a linear path. This made the construction of the scenes much more straightforward, due to the simplicity of the transition structure. Additionally, it made the question of backtracking a non-issue, since each scene source has a unique path backwards.
